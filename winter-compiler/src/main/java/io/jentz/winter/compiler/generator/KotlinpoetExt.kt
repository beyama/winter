package io.jentz.winter.compiler.generator

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.metadata.KotlinPoetMetadataPreview
import io.jentz.winter.compiler.ISO8601_FORMAT
import io.jentz.winter.compiler.WinterProcessor
import io.jentz.winter.compiler.now
import javax.inject.Provider

private val JAVAX_PROVIDER_INTERFACE_NAME = Provider::class.asClassName()

private val KOTLIN_PROVIDER_INTERFACE_NAME = Function0::class.asClassName()

private val JVM_PROVIDER_INTERFACE_NAME = ClassName("kotlin.jvm.functions", "Function0")

private val LAZY_INTERFACE_NAME = Lazy::class.asClassName()

val TypeName.isJavaxProvider: Boolean
    get() = (this as? ParameterizedTypeName)?.rawType == JAVAX_PROVIDER_INTERFACE_NAME

val TypeName.isProvider: Boolean
    get() {
        val raw = (this as? ParameterizedTypeName)?.rawType ?: return false
        return raw == KOTLIN_PROVIDER_INTERFACE_NAME || raw == JVM_PROVIDER_INTERFACE_NAME
    }

val TypeName.isLazy: Boolean
    get() = (this as? ParameterizedTypeName)?.rawType == LAZY_INTERFACE_NAME


fun TypeName.getInstanceCode(isNullable: Boolean, qualifier: String?): CodeBlock {
    val instanceMethod = if (isNullable) "instanceOrNull" else "instance"

    return when {
        isJavaxProvider -> {
            val typeName = (this as ParameterizedTypeName).typeArguments.first()
            CodeBlock.of("{ graph.$instanceMethod<%T>(${resolverArguments(typeName, qualifier)}) }", typeName)
        }
        isProvider -> {
            val providerMethod = if (isNullable) "providerOrNull" else "provider"
            val typeName = (this as ParameterizedTypeName).typeArguments.first()
            CodeBlock.of("graph.$providerMethod<%T>(${resolverArguments(this, qualifier)})", typeName)
        }
        isLazy -> {
            val typeName = (this as ParameterizedTypeName).typeArguments.first()
            CodeBlock.of("lazy { graph.$instanceMethod<%T>(${resolverArguments(this, qualifier)}) }", typeName)
        }
        else -> {
            CodeBlock.of("graph.$instanceMethod<%T>(${resolverArguments(this, qualifier)})", this)
        }
    }
}

private fun resolverArguments(typeName: TypeName, qualifier: String?): String {
    val arguments = mutableListOf<String>()
    if (qualifier != null)
        arguments += "qualifier = \"$qualifier\""
    if (typeName is ParameterizedTypeName)
        arguments += "generics = true"
    return arguments.joinToString()
}

@KotlinPoetMetadataPreview
fun TypeSpec.Builder.generatedAnnotation(generatedAnnotationName: ClassName?): TypeSpec.Builder {
    if (generatedAnnotationName != null)
        addAnnotation(io.jentz.winter.compiler.generator.generatedAnnotation(generatedAnnotationName))
    else
        addKdoc(generatedComment())
    return this
}

@KotlinPoetMetadataPreview
fun PropertySpec.Builder.generatedAnnotation(generatedAnnotationName: ClassName?): PropertySpec.Builder {
    if (generatedAnnotationName != null)
        addAnnotation(io.jentz.winter.compiler.generator.generatedAnnotation(generatedAnnotationName))
    else
        addKdoc(generatedComment())
    return this
}



@KotlinPoetMetadataPreview
private fun generatedAnnotation(generatedAnnotationName: ClassName) = AnnotationSpec
    .builder(generatedAnnotationName)
    .addMember("value = [%S]", WinterProcessor::class.java.name)
    .addMember("date = %S", ISO8601_FORMAT.format(now()))
    .build()

@KotlinPoetMetadataPreview
private fun generatedComment() =
    "Generated by ${WinterProcessor::class.java.name} at ${ISO8601_FORMAT.format(now())}\")"