package io.jentz.winter.compiler

import com.squareup.javapoet.*
import io.jentz.winter.ClassTypeKey
import io.jentz.winter.GenericClassTypeKey
import javax.inject.Provider

private val JAVAX_PROVIDER_INTERFACE_NAME: ClassName = ClassName.get(Provider::class.java)

private val PROVIDER_INTERFACE_NAME: ClassName = ClassName.get(Function0::class.java)

private val LAZY_INTERFACE_NAME: ClassName = ClassName.get(Lazy::class.java)

private val JVM_CLASS_MAPPING_NAME = ClassName.get("kotlin.jvm", "JvmClassMappingKt")

val TypeName.isJavaxProvider: Boolean
    get() = (this as? ParameterizedTypeName)?.rawType == JAVAX_PROVIDER_INTERFACE_NAME

val TypeName.isProvider: Boolean
    get() = (this as? ParameterizedTypeName)?.rawType == PROVIDER_INTERFACE_NAME

val TypeName.isLazy: Boolean
    get() = (this as? ParameterizedTypeName)?.rawType == LAZY_INTERFACE_NAME

fun TypeName.newTypeKeyCode(qualifier: String?): CodeBlock {
    return if (this is ParameterizedTypeName) {
        val typeKeyName = ClassName.get(GenericClassTypeKey::class.java)
        val parameterizedTypeKeyName = ParameterizedTypeName.get(typeKeyName, this)

        CodeBlock.of("new \$T(\$S) {}", parameterizedTypeKeyName, qualifier)
    } else {
        val typeKeyName = ClassName.get(ClassTypeKey::class.java)
        CodeBlock.of("new \$T<>(\$T.class, \$S)", typeKeyName, this, qualifier)
    }
}

fun TypeName.getInstanceCode(isNullable: Boolean, qualifier: String?): CodeBlock {
    val instanceByKeyMethod = if (isNullable) "instanceOrNullByKey" else "instanceByKey"

    return when {
        isJavaxProvider -> {
            val typeName = (this as ParameterizedTypeName).typeArguments.first()
            CodeBlock.of("() -> graph.$instanceByKeyMethod(\$L)", typeName.newTypeKeyCode(qualifier))
        }
        isProvider -> {
            val providerByKeyMethod = if (isNullable) "providerOrNullByKey" else "providerByKey"
            val typeName = (this as ParameterizedTypeName).typeArguments.first()
            CodeBlock.of("graph.$providerByKeyMethod(\$L)", typeName.newTypeKeyCode(qualifier))
        }
        isLazy -> {
            val lazyName = ClassName.get(Lazy::class.java.`package`.name, "LazyKt")
            val typeName = (this as ParameterizedTypeName).typeArguments.first()
            CodeBlock.of("\$T.lazy(() -> graph.$instanceByKeyMethod(\$L))", lazyName, typeName.newTypeKeyCode(qualifier))
        }
        else -> {
            val typeKeyCode = newTypeKeyCode(qualifier)
            CodeBlock.of("graph.$instanceByKeyMethod(\$L)", typeKeyCode)
        }
    }
}

fun TypeSpec.Builder.generatedAnnotation(generatedAnnotationName: ClassName?): TypeSpec.Builder {
    val processorName = WinterProcessor::class.java.name
    if (generatedAnnotationName != null) {
        val generatedAnnotation = AnnotationSpec
            .builder(generatedAnnotationName)
            .addMember("value", "\$S", processorName)
            .addMember("date", "\$S", ISO8601_FORMAT.format(now()))
            .build()

        addAnnotation(generatedAnnotation)
    } else {
        addJavadoc("Generated by $processorName at ${ISO8601_FORMAT.format(now())}\")")
    }
    return this
}

fun ClassName.toGetKotlinKClassCodeBlock(): CodeBlock =
    CodeBlock.of("\$T.getKotlinClass(\$T.class)", JVM_CLASS_MAPPING_NAME, this)

fun Class<*>.toClassName(): ClassName = ClassName.get(this)
